{% extends 'exercises/base.html' %}

{% block title %}Create Exercise - Practika{% endblock %}

{% block content %}
<style>
    .recording-controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 1.5rem;
        align-items: center;
    }
    
    .btn {
        transition: all 0.3s ease;
        border: none;
        cursor: pointer;
        font-weight: 600;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: center;
    }
    
    .btn-large {
        padding: 1rem 2rem;
        font-size: 1.1rem;
        border-radius: 8px;
        min-width: 160px;
    }
    
    .btn-small {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        border-radius: 6px;
        min-width: 120px;
    }
    
    .btn-primary {
        background: #3498db;
        color: white;
    }
    
    .btn-primary:hover {
        background: #2980b9;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
    }
    
    .btn-danger {
        background: #e74c3c;
        color: white;
    }
    
    .btn-danger:hover {
        background: #c0392b;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
    }
    
    .btn-success {
        background: #27ae60;
        color: white;
    }
    
    .btn-success:hover {
        background: #229954;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
    }
    
    .btn-secondary {
        background: #95a5a6;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #7f8c8d;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(149, 165, 166, 0.3);
    }
    
    .hidden {
        display: none !important;
    }
    
    .recording-status.ready {
        background: rgba(39, 174, 96, 0.9);
        animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
    }
</style>

<div class="create-exercise-container">
    <div class="header">
        <h2>üé• Create New Exercise</h2>
        <p class="subtitle">Record with webcam or upload a video file</p>
    </div>
    
    <form id="exercise-form" method="POST" enctype="multipart/form-data" action="{% url 'exercise_create' %}">
        {% csrf_token %}
        
        <!-- Basic Info Section -->
        <div class="form-section">
            <div class="form-group">
                <label for="name">Exercise Name *</label>
                <input type="text" id="name" name="name" required maxlength="140" 
                       placeholder="e.g., Morning Yoga Flow, Strength Training">
            </div>
            
            <div class="form-group">
                <label for="description">Description (optional)</label>
                <textarea id="description" name="description" rows="3" 
                          placeholder="Brief description of the exercise..."></textarea>
            </div>
        </div>
        
        <!-- Video Input Section -->
        <div class="form-section">
            <div class="video-source-toggle">
                <label class="toggle-label">Video Source</label>
                <div class="toggle-buttons">
                    <button type="button" class="toggle-btn active" data-source="webcam" aria-label="Record with webcam" title="Webcam">
                        <svg class="icon"><use href="/static/icons/icons.svg#camera"/></svg>
                        <span class="label-text">Webcam</span>
                    </button>
                    <button type="button" class="toggle-btn" data-source="file" aria-label="Upload video file" title="Upload File">
                        <svg class="icon"><use href="/static/icons/icons.svg#upload"/></svg>
                        <span class="label-text">Upload File</span>
                    </button>
                </div>
            </div>
            
            <!-- Webcam Recording -->
            <div id="webcam-section" class="video-section active">
                <div class="recorder-simple">
                    <div class="camera-preview">
                        <video id="preview-create" autoplay muted></video>
                        <div class="camera-overlay">
                            <div class="recording-status" id="recording-status">Ready to record</div>
                            <div class="recording-time" id="recording-time"></div>
                        </div>
                    </div>
                    
                    <div class="recording-controls">
                        <button type="button" id="record-toggle-btn" class="btn btn-primary btn-large" aria-label="Start recording video" title="Start Recording">
                            <svg class="icon icon-large"><use href="/static/icons/icons.svg#record"/></svg>
                            <span class="label-text">Start Recording</span>
                        </button>
                        <button type="button" id="upload-video-btn" class="btn btn-success btn-large hidden" aria-label="Upload recorded video" title="Upload Video">
                            <svg class="icon icon-large"><use href="/static/icons/icons.svg#save"/></svg>
                            <span class="label-text">Upload Video</span>
                        </button>
                        <button type="button" id="reset-recording" class="btn btn-secondary btn-small" aria-label="Record video again" title="Record Again">
                            <svg class="icon icon-small"><use href="/static/icons/icons.svg#camera"/></svg>
                            <span class="label-text">Record Again</span>
                        </button>
                    </div>
                    
                    <div class="recording-info">
                        <div class="info-item">
                            <span class="icon">üìπ</span>
                            <span id="video-status">No video recorded yet</span>
                        </div>
                        <div class="info-item">
                            <span class="icon">‚è±Ô∏è</span>
                            <span id="video-duration">0:00</span>
                        </div>
                        <div class="info-item" id="video-ready-indicator" style="display: none;">
                            <span class="icon">‚úÖ</span>
                            <span style="color: green; font-weight: bold;">Video Ready!</span>
                        </div>
                        <div class="info-item">
                            <button type="button" id="debug-video-btn" class="btn btn-small" style="display: none;" onclick="debugVideoStatus()">
                                üîç Debug Video
                            </button>
                            <button type="button" id="force-data-btn" class="btn btn-small" style="display: none;" onclick="forceDataCollection()">
                                üì° Force Data
                            </button>
                            <button type="button" id="test-recording-btn" class="btn btn-small" style="display: none;" onclick="testRecording()">
                                üß™ Test Recording
                            </button>
                            <button type="button" id="recovery-btn" class="btn btn-small" style="display: none;" onclick="attemptRecovery()">
                                üîÑ Attempt Recovery
                            </button>
                            <button type="button" id="manual-capture-btn" class="btn btn-small" style="display: none;" onclick="manualCapture()">
                                üì∏ Manual Capture
                            </button>
                            <button type="button" id="canvas-capture-btn" class="btn btn-small" style="display: none;" onclick="canvasCapture()">
                                üé® Canvas Capture
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- File Upload -->
            <div id="file-section" class="video-section">
                <div class="file-upload-area">
                    <div class="upload-zone" id="upload-zone">
                        <div class="upload-icon">üìÅ</div>
                        <div class="upload-text">
                            <strong>Click to select video</strong><br>
                            or drag and drop here
                        </div>
                        <input type="file" id="video-file" name="video" accept="video/*" hidden>
                    </div>
                    
                    <div class="file-preview" id="file-preview" style="display: none;">
                        <video id="video-preview" controls></video>
                        <div class="file-info">
                            <span id="file-name"></span>
                            <span id="file-size"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Progress Section -->
        <div id="progress-section" class="progress-section" style="display: none;">
            <div class="progress-header">
                <h4>üîÑ Creating Exercise...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>
            
            <div class="progress-steps">
                <div class="step" id="step-1">
                    <div class="step-icon">1</div>
                    <div class="step-content">
                        <div class="step-title">Validating</div>
                        <div class="step-status" id="step-1-status">Checking details...</div>
                    </div>
                </div>
                <div class="step" id="step-2">
                    <div class="step-icon">2</div>
                    <div class="step-content">
                        <div class="step-title">Processing Video</div>
                        <div class="step-status" id="step-2-status">Waiting...</div>
                    </div>
                </div>
                <div class="step" id="step-3">
                    <div class="step-icon">3</div>
                    <div class="step-content">
                        <div class="step-title">Uploading</div>
                        <div class="step-status" id="step-3-status">Waiting...</div>
                    </div>
                </div>
                <div class="step" id="step-4">
                    <div class="step-icon">4</div>
                    <div class="step-content">
                        <div class="step-title">Saving</div>
                        <div class="step-status" id="step-4-status">Waiting...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Hidden video input for form submission -->
        <input type="hidden" id="video-data" name="video_data">
        
        <!-- Action Buttons -->
        <div class="form-actions">
            <button type="submit" id="submit-btn" class="btn btn-secondary btn-large" disabled aria-label="Create exercise" title="Create Exercise">
                <svg class="icon icon-large"><use href="/static/icons/icons.svg#save"/></svg>
                <span class="label-text">Create Exercise</span>
            </button>
            <a href="{% url 'exercise_list' %}" class="btn btn-secondary" aria-label="Cancel and return to exercise list" title="Cancel">
                <svg class="icon icon-large"><use href="/static/icons/icons.svg#back"/></svg>
                <span class="label-text">Cancel</span>
            </a>
        </div>
    </form>
</div>

<script>
    // Simple Video Recorder for Create Page
    class SimpleVideoRecorder {
        constructor() {
            this.stream = null;
            this.mediaRecorder = null;
            this.recordedChunks = [];
            this.isRecording = false;
            this.recordingStartTime = null;
            this.durationTimer = null;
            
            this.setupElements();
            this.bindEvents();
        }
        
        setupElements() {
            this.preview = document.getElementById('preview-create');
            this.recordToggleBtn = document.getElementById('record-toggle-btn');
            this.uploadBtn = document.getElementById('upload-video-btn');
            this.resetBtn = document.getElementById('reset-recording');
            this.status = document.getElementById('recording-status');
            this.time = document.getElementById('recording-time');
            this.videoStatus = document.getElementById('video-status');
            this.videoDuration = document.getElementById('video-duration');
            
            // Check if all required elements are found
            if (!this.preview || !this.recordToggleBtn || !this.uploadBtn || !this.resetBtn || !this.status || !this.time || !this.videoStatus || !this.videoDuration) {
                throw new Error('Required DOM elements not found for video recorder');
            }
        }
        
        bindEvents() {
            try {
                this.recordToggleBtn.addEventListener('click', () => this.toggleRecording());
                this.uploadBtn.addEventListener('click', () => this.uploadVideo());
                this.resetBtn.addEventListener('click', () => this.reset());
            } catch (error) {
                console.error('Failed to bind video recorder events:', error);
                throw error;
            }
        }
        
        async startRecording() {
            try {
                this.status.textContent = 'Starting...';
                
                // Clear any previous recordings
                this.recordedChunks = [];
                
                // Heroku HTTPS requirement - ensure we're using secure context
                if (!window.isSecureContext) {
                    throw new Error('Camera access requires HTTPS (required on Heroku)');
                }
                
                this.stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }, 
                    audio: { 
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                console.log('Stream obtained:', {
                    active: this.stream.active,
                    tracks: this.stream.getTracks().map(t => ({ kind: t.kind, enabled: t.enabled, readyState: t.readyState }))
                });
                
                this.preview.srcObject = this.stream;
                // Test MIME types and find one that actually works
                const mimeTypes = [
                    'video/webm;codecs=vp8,opus',  // Most compatible
                    'video/webm;codecs=vp8',       // Basic webm
                    'video/webm',                   // Generic webm
                    'video/mp4',                    // MP4 fallback
                    'video/webm;codecs=vp9,opus'   // VP9 last (can cause issues)
                ];
                
                let selectedMimeType = null;
                let testRecorder = null;
                
                // Test each MIME type to find one that actually produces data
                for (const mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        try {
                            console.log('Testing MIME type:', mimeType);
                            testRecorder = new MediaRecorder(this.stream, { mimeType });
                            
                            // Test if this MIME type actually produces data
                            let hasData = false;
                            testRecorder.ondataavailable = (event) => {
                                if (event.data.size > 0) {
                                    hasData = true;
                                    console.log('MIME type test successful:', mimeType, 'size:', event.data.size);
                                }
                            };
                            
                            testRecorder.start();
                            setTimeout(() => {
                                testRecorder.stop();
                                if (hasData) {
                                    selectedMimeType = mimeType;
                                    console.log('Selected working MIME type:', selectedMimeType);
                                }
                            }, 100);
                            
                            if (selectedMimeType) break;
                            
                        } catch (error) {
                            console.log('MIME type test failed:', mimeType, error.message);
                        }
                    }
                }
                
                if (!selectedMimeType) {
                    console.error('No working MIME type found, using default');
                    selectedMimeType = 'video/webm'; // Fallback to default
                }
                
                console.log('Creating MediaRecorder with MIME type:', selectedMimeType);
                
                try {
                    this.mediaRecorder = new MediaRecorder(this.stream, {
                        mimeType: selectedMimeType
                    });
                    console.log('MediaRecorder created successfully');
                } catch (error) {
                    console.error('Failed to create MediaRecorder:', error);
                    // Try without MIME type as fallback
                    try {
                        this.mediaRecorder = new MediaRecorder(this.stream);
                        console.log('MediaRecorder created without MIME type as fallback');
                    } catch (fallbackError) {
                        console.error('Failed to create MediaRecorder even without MIME type:', fallbackError);
                        throw fallbackError;
                    }
                }
                
                this.mediaRecorder.ondataavailable = (event) => {
                    console.log('Data available event:', { size: event.data.size, type: event.data.type });
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                        console.log('Video chunk received:', { size: event.data.size, totalChunks: this.recordedChunks.length });
                    } else {
                        console.warn('Empty data chunk received - trying to force data collection');
                        // Try to force data collection if we're getting empty chunks
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            setTimeout(() => {
                                try {
                                    this.mediaRecorder.requestData();
                                } catch (error) {
                                    console.error('Error forcing data collection:', error);
                                }
                            }, 100);
                        }
                    }
                };
                
                this.mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    this.status.textContent = 'Recording error: ' + event.error.message;
                    this.isRecording = false;
                    this.updateUI();
                };
                
                this.mediaRecorder.onstart = () => {
                    console.log('MediaRecorder started successfully');
                };
                
                this.mediaRecorder.onstop = () => {
                    console.log('MediaRecorder stopped, requesting final data');
                    // Request any remaining data
                    if (this.mediaRecorder.state === 'inactive') {
                        this.mediaRecorder.requestData();
                    }
                };
                
                // Start recording with more frequent data collection
                try {
                    this.mediaRecorder.start(50); // Every 50ms for more frequent data collection
                    console.log('MediaRecorder.start() called successfully with 50ms intervals');
                } catch (error) {
                    console.error('Failed to start MediaRecorder:', error);
                    throw error;
                }
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.startDurationTimer();
                this.updateUI();
                
                this.status.textContent = 'Recording...';
                this.status.className = 'recording-status recording';
                
                console.log('Recording started');
                
            } catch (error) {
                console.error('Camera error:', error);
                
                // Heroku-specific error messages
                if (error.name === 'NotAllowedError') {
                    this.status.textContent = 'Camera access denied - please allow camera permissions';
                } else if (error.name === 'NotSupportedError') {
                    this.status.textContent = 'Camera not supported - please use a modern browser';
                } else if (error.message.includes('HTTPS')) {
                    this.status.textContent = 'HTTPS required for camera access (Heroku requirement)';
                } else {
                    this.status.textContent = 'Camera error: ' + error.message;
                }
                
                // Reset recording state on error
                this.isRecording = false;
                this.updateUI();
            }
        }
        
        toggleRecording() {
            if (this.isRecording) {
                this.stopRecording();
            } else {
                this.startRecording();
            }
        }
        
        uploadVideo() {
            try {
                // Validate video before upload
                const validation = this.validateVideoForUpload();
                if (!validation.valid) {
                    alert('Video validation failed: ' + validation.error);
                    return;
                }
                
                const videoBlob = validation.blob;
                
                // Create a file input for the webcam video
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.name = 'video';
                fileInput.style.display = 'none';
                
                // Convert blob to file
                const videoFile = new File([videoBlob], 'exercise.webm', { type: 'video/webm' });
                
                // Create a new DataTransfer and add the file
                const dt = new DataTransfer();
                dt.items.add(videoFile);
                fileInput.files = dt.files;
                
                // Remove any existing video input first
                const existingVideoInput = document.querySelector('input[name="video"]');
                if (existingVideoInput) {
                    existingVideoInput.remove();
                }
                
                // Add to form
                document.getElementById('exercise-form').appendChild(fileInput);
                
                console.log('Video prepared for upload:', { fileName: videoFile.name, fileSize: videoFile.size });
                
                // Heroku performance logging
                if (isHeroku) {
                    console.log('Heroku: Video upload prepared successfully', {
                        size: videoFile.size,
                        duration: this.recordingStartTime ? Math.round((Date.now() - this.recordingStartTime) / 1000) : 'unknown',
                        chunks: this.recordedChunks.length
                    });
                }
                
                // Update UI to show video is ready
                this.status.textContent = 'Video Ready for Upload!';
                this.status.className = 'recording-status ready';
                
                // Enable the submit button
                document.getElementById('submit-btn').disabled = false;
                document.getElementById('submit-btn').classList.add('btn-success');
                document.getElementById('submit-btn').classList.remove('btn-secondary');
                
                // Show video ready indicator
                document.getElementById('video-ready-indicator').style.display = 'block';
                
                // Update button states
                this.updateUI();
                
                alert('Video has been prepared for upload! You can now submit the exercise.');
                
            } catch (error) {
                console.error('Error preparing video for upload:', error);
                alert('Error preparing video for upload: ' + error.message);
            }
        }
        
        startDurationTimer() {
            this.durationTimer = setInterval(() => {
                if (this.isRecording && this.recordingStartTime) {
                    const duration = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    this.time.textContent = timeString;
                    this.videoDuration.textContent = timeString;
                }
            }, 1000);
        }
        
        stopRecording() {
            if (this.mediaRecorder && this.isRecording) {
                console.log('Stopping recording...');
                clearInterval(this.durationTimer);
                
                this.isRecording = false;
                
                // IMPORTANT: Request data BEFORE stopping the MediaRecorder
                console.log('Requesting final data before stopping...');
                try {
                    this.mediaRecorder.requestData();
                    console.log('Final data requested successfully');
                } catch (error) {
                    console.error('Error requesting final data:', error);
                }
                
                // Wait a moment for data to be collected, then stop
                setTimeout(() => {
                    try {
                        console.log('Stopping MediaRecorder after data collection...');
                        this.mediaRecorder.stop();
                        console.log('MediaRecorder.stop() called');
                    } catch (error) {
                        console.error('Error stopping MediaRecorder:', error);
                    }
                }, 500); // Wait 500ms for data collection
                
                // DON'T stop the stream yet - wait for data collection
                console.log('Keeping stream active for data collection...');
                
                this.status.textContent = 'Processing...';
                this.status.className = 'recording-status processing';
                
                // Wait for the final data to be available
                this.mediaRecorder.onstop = () => {
                    console.log('MediaRecorder onstop triggered');
                    
                    // Process the collected data
                    setTimeout(() => {
                        console.log('Processing final data, chunks:', this.recordedChunks.length);
                        
                        // If we still have no chunks, try recovery
                        if (this.recordedChunks.length === 0) {
                            console.warn('No chunks collected, attempting recovery...');
                            this.attemptImmediateRecovery();
                        }
                        
                        this.status.textContent = 'Video Ready!';
                        this.status.className = 'recording-status ready';
                        this.videoStatus.textContent = 'Video ready for upload';
                        
                        // Show video ready indicator
                        document.getElementById('video-ready-indicator').style.display = 'block';
                        
                        // Show debug button
                        document.getElementById('debug-video-btn').style.display = 'inline-block';
                        
                        // Show force data button
                        document.getElementById('force-data-btn').style.display = 'inline-block';
                        
                        // Show test recording button
                        document.getElementById('test-recording-btn').style.display = 'inline-block';
                        
                        // Show recovery button if no chunks
                        if (this.recordedChunks.length === 0) {
                            document.getElementById('recovery-btn').style.display = 'inline-block';
                            document.getElementById('manual-capture-btn').style.display = 'inline-block';
                            document.getElementById('canvas-capture-btn').style.display = 'inline-block';
                        }
                        
                        console.log('Video recording completed and ready, chunks:', this.recordedChunks.length);
                        
                        // NOW stop the stream after we have data
                        if (this.stream) {
                            this.stream.getTracks().forEach(track => {
                                track.stop();
                                console.log('Track stopped after data collection:', track.kind);
                            });
                            this.stream = null;
                        }
                        
                        // Update UI to show upload button
                        this.updateUI();
                        
                        // Note: Submit button will be enabled when Upload Video is clicked
                    }, 1000); // Increased timeout for better data collection
                };
            }
        }
        
        updateUI() {
            console.log('updateUI called:', { 
                isRecording: this.isRecording, 
                chunks: this.recordedChunks.length,
                hasVideo: this.hasVideo()
            });
            
            if (this.isRecording) {
                // Recording state: show stop button
                this.recordToggleBtn.innerHTML = '<svg class="icon icon-large"><use href="/static/icons/icons.svg#stop"/></svg><span class="label-text">Stop Recording</span>';
                this.recordToggleBtn.className = 'btn btn-danger btn-large';
                this.recordToggleBtn.classList.remove('hidden');
                this.uploadBtn.classList.add('hidden');
                this.resetBtn.classList.add('hidden');
            } else if (this.isReadyForUpload()) {
                // Ready state: show upload button
                this.recordToggleBtn.classList.add('hidden');
                this.uploadBtn.classList.remove('hidden');
                this.resetBtn.classList.remove('hidden');
            } else {
                // Initial state: show record button
                this.recordToggleBtn.innerHTML = '<svg class="icon icon-large"><use href="/static/icons/icons.svg#record"/></svg><span class="label-text">Start Recording</span>';
                this.recordToggleBtn.className = 'btn btn-primary btn-large';
                this.recordToggleBtn.classList.remove('hidden');
                this.uploadBtn.classList.add('hidden');
                this.resetBtn.classList.add('hidden');
            }
        }
        
        getVideoBlob() {
            console.log('getVideoBlob() called, chunks:', this.recordedChunks ? this.recordedChunks.length : 0);
            if (this.recordedChunks && this.recordedChunks.length > 0) {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                console.log('Video blob created:', { size: blob.size, chunks: this.recordedChunks.length });
                return blob;
            }
            console.log('No video chunks available');
            return null;
        }
        
        hasVideo() {
            const blob = this.getVideoBlob();
            const hasVideo = blob !== null && blob.size > 0;
            console.log('hasVideo() called:', { hasVideo, blobExists: !!blob, blobSize: blob ? blob.size : 0 });
            return hasVideo;
        }
        
        isReadyForUpload() {
            return this.recordedChunks.length > 0 && this.hasVideo();
        }
        
        validateVideoForUpload() {
            const blob = this.getVideoBlob();
            if (!blob || blob.size === 0) {
                return { valid: false, error: 'No video data available' };
            }
            
            // Check file size (100MB limit for Heroku)
            const maxSize = 100 * 1024 * 1024;
            if (blob.size > maxSize) {
                return { 
                    valid: false, 
                    error: `Video too large (${(blob.size / 1024 / 1024).toFixed(1)}MB). Maximum is 100MB.` 
                };
            }
            
            // Check duration (max 10 minutes)
            if (this.recordingStartTime) {
                const duration = Date.now() - this.recordingStartTime;
                const maxDuration = 10 * 60 * 1000; // 10 minutes
                if (duration > maxDuration) {
                    return { 
                        valid: false, 
                        error: `Video too long (${Math.round(duration / 1000 / 60)} minutes). Maximum is 10 minutes.` 
                    };
                }
            }
            
            return { valid: true, blob };
        }
        
        forceRefreshVideo() {
            // Force a refresh of the video blob
            if (this.recordedChunks.length > 0) {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                console.log('Force refreshed video blob:', { size: blob.size, chunks: this.recordedChunks.length });
                return blob;
            }
            return null;
        }
        
        requestData() {
            // Manually request data from MediaRecorder if it's still active
            if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                console.log('Manually requesting data from MediaRecorder');
                this.mediaRecorder.requestData();
            }
        }
        
        forceDataCollection() {
            console.log('=== FORCING DATA COLLECTION ===');
            
            // Try to request data if still recording
            this.requestData();
            
            // Check current state
            console.log('Current chunks:', this.recordedChunks ? this.recordedChunks.length : 0);
            
            // Try to create a blob anyway
            const blob = this.forceRefreshVideo();
            if (blob) {
                console.log('Successfully created blob after force refresh:', { size: blob.size });
                return blob;
            } else {
                console.log('Still no data available');
                return null;
            }
        }
        
        testRecording() {
            console.log('=== TESTING RECORDING ===');
            console.log('Stream active:', this.stream ? this.stream.active : false);
            console.log('MediaRecorder state:', this.mediaRecorder ? this.mediaRecorder.state : 'null');
            console.log('Current chunks:', this.recordedChunks.length);
            
            if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                console.log('Requesting data from active MediaRecorder...');
                this.mediaRecorder.requestData();
            }
            
            // Try to recover if we have no chunks but stream is active
            if (this.recordedChunks.length === 0 && this.stream && this.stream.active) {
                console.log('Attempting to recover recording data...');
                this.attemptDataRecovery();
            }
        }
        
        attemptDataRecovery() {
            console.log('=== ATTEMPTING DATA RECOVERY ===');
            
            // Try to create a new MediaRecorder if the old one is inactive
            if (this.stream && this.stream.active) {
                try {
                    console.log('Creating new MediaRecorder for recovery...');
                    const newRecorder = new MediaRecorder(this.stream);
                    
                    newRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                            console.log('Recovery chunk received:', { size: event.data.size, totalChunks: this.recordedChunks.length });
                        }
                    };
                    
                    // Start recording for a short time to capture data
                    newRecorder.start();
                    setTimeout(() => {
                        newRecorder.stop();
                        console.log('Recovery recording stopped, chunks:', this.recordedChunks.length);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Recovery failed:', error);
                }
            }
        }
        
        attemptImmediateRecovery() {
            console.log('=== ATTEMPTING IMMEDIATE RECOVERY ===');
            
            // If stream is still active, try to capture data immediately
            if (this.stream && this.stream.active) {
                try {
                    console.log('Stream still active, attempting immediate capture...');
                    
                    // Try multiple MIME types for recovery
                    const recoveryMimeTypes = ['video/webm', 'video/webm;codecs=vp8', 'video/mp4'];
                    
                    for (const mimeType of recoveryMimeTypes) {
                        if (MediaRecorder.isTypeSupported(mimeType)) {
                            try {
                                console.log('Trying recovery with MIME type:', mimeType);
                                const recoveryRecorder = new MediaRecorder(this.stream, { mimeType });
                                
                                recoveryRecorder.ondataavailable = (event) => {
                                    if (event.data.size > 0) {
                                        this.recordedChunks.push(event.data);
                                        console.log('Recovery chunk received:', { size: event.data.size, totalChunks: this.recordedChunks.length, type: mimeType });
                                    }
                                };
                                
                                // Start recording for a short time
                                recoveryRecorder.start();
                                
                                // Stop after 500ms to get data
                                setTimeout(() => {
                                    recoveryRecorder.stop();
                                    console.log('Recovery completed with', mimeType, 'chunks:', this.recordedChunks.length);
                                }, 500);
                                
                                break; // Use the first working MIME type
                                
                            } catch (error) {
                                console.error('Recovery failed with', mimeType, ':', error);
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('Immediate recovery failed:', error);
                }
            } else {
                console.log('Stream not active, cannot attempt immediate recovery');
            }
        }
        
        createVideoFromCanvas() {
            console.log('=== CREATING VIDEO FROM CANVAS ===');
            
            try {
                // Create a canvas element
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size to match video
                canvas.width = this.preview.videoWidth || 640;
                canvas.height = this.preview.videoHeight || 480;
                
                // Draw the current video frame to canvas
                ctx.drawImage(this.preview, 0, 0, canvas.width, canvas.height);
                
                // Convert canvas to blob
                canvas.toBlob((blob) => {
                    if (blob && blob.size > 0) {
                        // Create a video file from the canvas
                        const videoBlob = new Blob([blob], { type: 'image/png' });
                        this.recordedChunks.push(videoBlob);
                        console.log('Canvas video created:', { size: videoBlob.size, totalChunks: this.recordedChunks.length });
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('Canvas video creation failed:', error);
            }
        }
        
        reset() {
            this.recordedChunks = [];
            this.preview.srcObject = null;
            this.preview.src = '';
            this.status.textContent = 'Ready to record';
            this.status.className = 'recording-status';
            this.time.textContent = '';
            this.videoStatus.textContent = 'No video recorded yet';
            this.videoDuration.textContent = '0:00';
            
            // Hide video ready indicator
            document.getElementById('video-ready-indicator').style.display = 'none';
            
            // Remove any existing video file input
            const existingVideoInput = document.querySelector('input[name="video"]');
            if (existingVideoInput) {
                existingVideoInput.remove();
            }
            
            // Disable submit button
            const submitBtn = document.getElementById('submit-btn');
            submitBtn.disabled = true;
            submitBtn.className = 'btn btn-secondary btn-large';
            
            // Reset button states
            this.updateUI();
        }
    }
    
    // Initialize when page loads
    let videoRecorder; // Declare globally
    
    // Heroku environment detection
    const isHeroku = window.location.hostname.includes('herokuapp.com') || 
                     window.location.protocol === 'https:';
    
    if (isHeroku) {
        console.log('Running on Heroku - HTTPS and security features enabled');
    }
    
    // Global error handler for unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        console.error('Unhandled promise rejection:', event.reason);
        // Prevent the default browser behavior
        event.preventDefault();
    });
    
    document.addEventListener('DOMContentLoaded', function() {
        try {
            // Check if SimpleVideoRecorder class is defined
            if (typeof SimpleVideoRecorder === 'undefined') {
                throw new Error('SimpleVideoRecorder class is not defined');
            }
            
            // Initialize video recorder
            videoRecorder = new SimpleVideoRecorder();
            console.log('VideoRecorder initialized:', videoRecorder);
            
            // Ensure initial UI state is correct
            videoRecorder.updateUI();
        } catch (error) {
            console.error('Failed to initialize VideoRecorder:', error);
            videoRecorder = null;
        }
        
        // Toggle between webcam and file upload
        const toggleBtns = document.querySelectorAll('.toggle-btn');
        const videoSections = document.querySelectorAll('.video-section');
        
        toggleBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const source = this.dataset.source;
                
                // Update toggle buttons
                toggleBtns.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Show/hide sections
                videoSections.forEach(section => {
                    section.classList.remove('active');
                    if (section.id === `${source}-section`) {
                        section.classList.add('active');
                    }
                });
            });
        });
        
        // File upload handling
        const uploadZone = document.getElementById('upload-zone');
        const videoFile = document.getElementById('video-file');
        const filePreview = document.getElementById('file-preview');
        const videoPreview = document.getElementById('video-preview');
        const fileName = document.getElementById('file-name');
        const fileSize = document.getElementById('file-size');
        
        uploadZone.addEventListener('click', () => videoFile.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });
        
        videoFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });
        
        function handleFileSelect(file) {
            if (file.type.startsWith('video/')) {
                const url = URL.createObjectURL(file);
                videoPreview.src = url;
                
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                
                uploadZone.style.display = 'none';
                filePreview.style.display = 'block';
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Progress tracking
        function updateStep(stepNumber, status, message) {
            const step = document.getElementById(`step-${stepNumber}`);
            const stepStatus = document.getElementById(`step-${stepNumber}-status`);
            const stepIcon = step.querySelector('.step-icon');
            
            step.className = `step ${status}`;
            stepIcon.className = `step-icon ${status}`;
            stepStatus.textContent = message;
            
            // Update progress bar
            const completedSteps = document.querySelectorAll('.step.completed').length;
            const progress = (completedSteps / 4) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
        }
        
        // Form submission
        document.getElementById('exercise-form').addEventListener('submit', function(e) {
            // Validate form
            const name = document.getElementById('name').value.trim();
            if (!name) {
                e.preventDefault();
                alert('Exercise name is required');
                return;
            }
            
            // Check if video is available
            const activeSource = document.querySelector('.toggle-btn.active').dataset.source;
            let hasVideo = false;
            
            if (activeSource === 'webcam') {
                // Check if videoRecorder is available
                if (!videoRecorder) {
                    console.error('VideoRecorder not available');
                    e.preventDefault();
                    alert('Video recorder not available. Please refresh the page and try again.');
                    return;
                }
                
                // More detailed webcam video check
                const videoBlob = videoRecorder.getVideoBlob();
                const hasVideoMethod = videoRecorder.hasVideo();
                hasVideo = hasVideoMethod && videoBlob && videoBlob.size > 0;
                
                console.log('Webcam video check:', { 
                    hasVideo, 
                    hasVideoMethod, 
                    blobExists: !!videoBlob, 
                    blobSize: videoBlob ? videoBlob.size : 0,
                    chunks: videoRecorder.recordedChunks ? videoRecorder.recordedChunks.length : 0
                });
                
                // If we have chunks but no blob, try to create one
                if (!hasVideo && videoRecorder.recordedChunks && videoRecorder.recordedChunks.length > 0) {
                    console.log('Attempting to create blob from chunks...');
                    const tempBlob = new Blob(videoRecorder.recordedChunks, { type: 'video/webm' });
                    if (tempBlob.size > 0) {
                        hasVideo = true;
                        console.log('Successfully created blob from chunks:', { size: tempBlob.size });
                    }
                }
            } else {
                const fileInput = document.getElementById('video-file');
                hasVideo = fileInput.files.length > 0 && fileInput.files[0].size > 0;
                console.log('File upload check:', { hasVideo, fileCount: fileInput.files.length });
            }
            
            if (!hasVideo) {
                e.preventDefault();
                alert('Please record or upload a video first. Make sure the video is complete and ready.');
                return;
            }
            
            // Check if webcam video has already been prepared for upload
            if (activeSource === 'webcam') {
                // The uploadVideo method should have already prepared the video
                // Just verify it's still available
                const existingVideoInput = document.querySelector('input[name="video"]');
                if (!existingVideoInput || !existingVideoInput.files || existingVideoInput.files.length === 0) {
                    e.preventDefault();
                    alert('Please use the Upload Video button to prepare your recorded video first.');
                    return;
                }
                
                // Additional validation for webcam video
                const videoFile = existingVideoInput.files[0];
                if (videoFile.size === 0) {
                    e.preventDefault();
                    alert('Video file appears to be empty. Please record a new video.');
                    return;
                }
                
                console.log('Webcam video validated for submission:', {
                    name: videoFile.name,
                    size: videoFile.size,
                    type: videoFile.type
                });
            }
            
            // Show progress
            const submitBtn = document.getElementById('submit-btn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Creating...';
        });
    });
    
    // Debug function to check video status
    function debugVideoStatus() {
        try {
            const activeSource = document.querySelector('.toggle-btn.active').dataset.source;
            console.log('=== VIDEO DEBUG INFO ===');
            console.log('Active source:', activeSource);
            
            if (activeSource === 'webcam') {
                if (typeof videoRecorder === 'undefined') {
                    console.error('ERROR: videoRecorder is not defined!');
                    console.log('Available global variables:', window && Object.keys(window) ? Object.keys(window).filter(key => key.includes('video') || key.includes('recorder')) : 'window not available');
                    return;
                }
                
                console.log('VideoRecorder state:', {
                    isRecording: videoRecorder.isRecording,
                    chunks: videoRecorder.recordedChunks ? videoRecorder.recordedChunks.length : 0,
                    hasVideo: videoRecorder.hasVideo(),
                    getVideoBlob: videoRecorder.getVideoBlob(),
                    forceRefresh: videoRecorder.forceRefreshVideo()
                });
            } else {
                const fileInput = document.getElementById('video-file');
                console.log('File input state:', {
                    files: fileInput.files,
                    fileCount: fileInput.files.length,
                    firstFile: fileInput.files[0] ? {
                        name: fileInput.files[0].name,
                        size: fileInput.files[0].size,
                        type: fileInput.files[0].type
                    } : null
                });
            }
            
            // Test form validation
            const name = document.getElementById('name').value.trim();
            console.log('Form validation test:', {
                name: name,
                nameValid: !!name
            });
            
            alert('Check browser console for detailed video debug information');
        } catch (error) {
            console.error('Debug function error:', error);
            alert('Error in debug function: ' + error.message);
        }
    }
    
    // Force data collection function
    function forceDataCollection() {
        try {
            if (typeof videoRecorder === 'undefined') {
                alert('VideoRecorder not available');
                return;
            }
            
            console.log('=== FORCING DATA COLLECTION ===');
            
            // Try to request data if still recording
            videoRecorder.requestData();
            
            // Check current state
            console.log('Current chunks:', videoRecorder.recordedChunks ? videoRecorder.recordedChunks.length : 0);
            
            // Try to create a blob anyway
            const blob = videoRecorder.forceRefreshVideo();
            if (blob) {
                console.log('Successfully created blob after force refresh:', { size: blob.size });
                alert('Data collected! Check console for details.');
            } else {
                console.log('Still no data available');
                alert('No data available even after force collection.');
            }
        } catch (error) {
            console.error('Force data collection error:', error);
            alert('Error in force data collection: ' + error.message);
        }
    }
    
    // Test recording function
    function testRecording() {
        try {
            if (typeof videoRecorder === 'undefined') {
                alert('VideoRecorder not available');
                return;
            }
            
            videoRecorder.testRecording();
        } catch (error) {
            console.error('Test recording error:', error);
            alert('Error in test recording: ' + error.message);
        }
    }
    
    // Attempt recovery function
    function attemptRecovery() {
        try {
            if (typeof videoRecorder === 'undefined') {
                alert('VideoRecorder not available');
                return;
            }
            
            videoRecorder.attemptDataRecovery();
        } catch (error) {
            console.error('Recovery error:', error);
            alert('Error in recovery: ' + error.message);
        }
    }
    
    // Manual capture function
    function manualCapture() {
        try {
            if (typeof videoRecorder === 'undefined') {
                alert('VideoRecorder not available');
                return;
            }
            
            videoRecorder.attemptImmediateRecovery();
        } catch (error) {
            console.error('Manual capture error:', error);
            alert('Error in manual capture: ' + error.message);
        }
    }
    
    // Canvas capture function
    function canvasCapture() {
        try {
            if (typeof videoRecorder === 'undefined') {
                alert('VideoRecorder not available');
                return;
            }
            
            videoRecorder.createVideoFromCanvas();
        } catch (error) {
            console.error('Canvas capture error:', error);
            alert('Error in canvas capture: ' + error.message);
        }
    }
</script>
{% endblock %}
