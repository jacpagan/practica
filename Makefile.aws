# AWS Operations Makefile for Practika Django App

.PHONY: help deploy build push logs status scale clean destroy migrate collectstatic test health

# Configuration
PROJECT_NAME = practika
AWS_REGION = us-east-1
CLUSTER_NAME = $(PROJECT_NAME)-prod
SERVICE_NAME = $(PROJECT_NAME)-service
STACK_NAME = $(PROJECT_NAME)-infrastructure

# Colors
GREEN = \033[0;32m
YELLOW = \033[1;33m
RED = \033[0;31m
NC = \033[0m # No Color

help: ## Show this help message
	@echo "AWS Operations for Practika Django App"
	@echo "======================================"
	@echo ""
	@echo "Available commands:"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}'

deploy: ## Deploy the entire application to AWS
	@echo "$(GREEN)Starting AWS deployment...$(NC)"
	@./deploy-aws.sh

build: ## Build Docker image for AWS
	@echo "$(GREEN)Building Docker image...$(NC)"
	docker build -f Dockerfile.aws -t $(PROJECT_NAME):aws .

push: ## Push Docker image to ECR
	@echo "$(GREEN)Pushing to ECR...$(NC)"
	@aws ecr get-login-password --region $(AWS_REGION) | docker login --username AWS --password-stdin $$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$(AWS_REGION).amazonaws.com
	docker tag $(PROJECT_NAME):aws $$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$(AWS_REGION).amazonaws.com/$(PROJECT_NAME):latest
	docker push $$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$(AWS_REGION).amazonaws.com/$(PROJECT_NAME):latest

logs: ## View ECS service logs
	@echo "$(GREEN)Fetching ECS logs...$(NC)"
	@aws logs describe-log-groups --log-group-name-prefix /ecs/$(CLUSTER_NAME) --region $(AWS_REGION)
	@echo ""
	@echo "To view specific logs, use:"
	@echo "aws logs tail /ecs/$(CLUSTER_NAME) --follow --region $(AWS_REGION)"

status: ## Check ECS service status
	@echo "$(GREEN)Checking ECS service status...$(NC)"
	@aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' --output table

scale: ## Scale ECS service (usage: make scale COUNT=3)
	@if [ -z "$(COUNT)" ]; then echo "$(RED)Please specify COUNT parameter$(NC)"; echo "Usage: make scale COUNT=3"; exit 1; fi
	@echo "$(GREEN)Scaling ECS service to $(COUNT) tasks...$(NC)"
	@aws ecs update-service --cluster $(CLUSTER_NAME) --service $(SERVICE_NAME) --desired-count $(COUNT) --region $(AWS_REGION)

clean: ## Clean up local Docker images
	@echo "$(GREEN)Cleaning up local Docker images...$(NC)"
	docker rmi $(PROJECT_NAME):aws 2>/dev/null || true
	docker system prune -f

destroy: ## Destroy all AWS infrastructure (DANGEROUS!)
	@echo "$(RED)WARNING: This will destroy ALL AWS infrastructure!$(NC)"
	@echo "Are you sure? Type 'yes' to confirm:"
	@read -p "> " confirm && [ "$$confirm" = "yes" ] || exit 1
	@echo "$(YELLOW)Destroying CloudFormation stack...$(NC)"
	@aws cloudformation delete-stack --stack-name $(STACK_NAME) --region $(AWS_REGION)
	@echo "$(YELLOW)Waiting for stack deletion...$(NC)"
	@aws cloudformation wait stack-delete-complete --stack-name $(STACK_NAME) --region $(AWS_REGION)
	@echo "$(GREEN)Infrastructure destroyed successfully$(NC)"

migrate: ## Run database migrations
	@echo "$(GREEN)Running database migrations...$(NC)"
	@TASK_DEF_ARN=$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].taskDefinition' --output text); \
	aws ecs run-task --cluster $(CLUSTER_NAME) --task-definition $$TASK_DEF_ARN --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].networkConfiguration.awsvpcConfiguration.subnets[]' --output text | tr '\t' ',')],securityGroups=[$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].networkConfiguration.awsvpcConfiguration.securityGroups[]' --output text | tr '\t' ',')],assignPublicIp=ENABLED}" --overrides '{"containerOverrides":[{"name":"practika-web","command":["python","manage.py","migrate","--noinput"]}]}' --region $(AWS_REGION)

collectstatic: ## Collect static files
	@echo "$(GREEN)Collecting static files...$(NC)"
	@TASK_DEF_ARN=$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].taskDefinition' --output text); \
	aws ecs run-task --cluster $(CLUSTER_NAME) --task-definition $$TASK_DEF_ARN --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].networkConfiguration.awsvpcConfiguration.subnets[]' --output text | tr '\t' ',')],securityGroups=[$$(aws ecs describe-services --cluster $(CLUSTER_NAME) --services $(SERVICE_NAME) --region $(AWS_REGION) --query 'services[0].networkConfiguration.awsvpcConfiguration.securityGroups[]' --output text | tr '\t' ',')],assignPublicIp=ENABLED}" --overrides '{"containerOverrides":[{"name":"practika-web","command":["python","manage.py","collectstatic","--noinput"]}]}' --region $(AWS_REGION)

test: ## Test the deployment health
	@echo "$(GREEN)Testing deployment health...$(NC)"
	@ALB_DNS=$$(aws cloudformation describe-stacks --stack-name $(STACK_NAME) --region $(AWS_REGION) --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' --output text); \
	if curl -f "http://$$ALB_DNS/core/health/" >/dev/null 2>&1; then \
		echo "$(GREEN)Health check passed! App is running at http://$$ALB_DNS$(NC)"; \
	else \
		echo "$(RED)Health check failed$(NC)"; \
		exit 1; \
	fi

health: ## Check application health endpoint
	@echo "$(GREEN)Checking application health...$(NC)"
	@ALB_DNS=$$(aws cloudformation describe-stacks --stack-name $(STACK_NAME) --region $(AWS_REGION) --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' --output text); \
	curl -s "http://$$ALB_DNS/core/health/" | jq . 2>/dev/null || curl -s "http://$$ALB_DNS/core/health/"

update: ## Update ECS service with new image
	@echo "$(GREEN)Updating ECS service...$(NC)"
	@aws ecs update-service --cluster $(CLUSTER_NAME) --service $(SERVICE_NAME) --force-new-deployment --region $(AWS_REGION)

monitor: ## Monitor ECS service metrics
	@echo "$(GREEN)ECS Service Metrics:$(NC)"
	@aws cloudwatch get-metric-statistics --namespace AWS/ECS --metric-name CPUUtilization --dimensions Name=ServiceName,Value=$(SERVICE_NAME) Name=ClusterName,Value=$(CLUSTER_NAME) --start-time $$(date -d '1 hour ago' --iso-8601=seconds) --end-time $$(date --iso-8601=seconds) --period 300 --statistics Average --region $(AWS_REGION) --query 'Datapoints[0].Average' --output text 2>/dev/null || echo "No data available"

costs: ## Get cost and usage information
	@echo "$(GREEN)Cost and Usage Information:$(NC)"
	@echo "Note: Cost data may be delayed by up to 24 hours"
	@aws ce get-cost-and-usage --time-period Start=$$(date -d '30 days ago' --iso-8601=date),End=$$(date --iso-8601=date) --granularity MONTHLY --metrics BlendedCost --group-by Type=DIMENSION,Key=SERVICE --region $(AWS_REGION) --query 'ResultsByTime[0].Groups[?contains(Keys[0].Value, `ECS`) || contains(Keys[0].Value, `RDS`) || contains(Keys[0].Value, `S3`)].{Service:Keys[0].Value,Cost:Metrics.BlendedCost.Amount}' --output table 2>/dev/null || echo "Cost data not available"

backup: ## Create manual database backup
	@echo "$(GREEN)Creating manual database backup...$(NC)"
	@DB_IDENTIFIER=$$(aws cloudformation describe-stacks --stack-name $(STACK_NAME) --region $(AWS_REGION) --query 'Stacks[0].Outputs[?OutputKey==`DatabaseEndpoint`].OutputValue' --output text | sed 's/\..*//'); \
	aws rds create-db-snapshot --db-instance-identifier $$DB_IDENTIFIER --db-snapshot-identifier $(PROJECT_NAME)-manual-$$(date +%Y%m%d-%H%M%S) --region $(AWS_REGION)

restart: ## Restart ECS service
	@echo "$(GREEN)Restarting ECS service...$(NC)"
	@aws ecs update-service --cluster $(CLUSTER_NAME) --service $(SERVICE_NAME) --force-new-deployment --region $(AWS_REGION)

info: ## Display deployment information
	@echo "$(GREEN)Deployment Information:$(NC)"
	@echo "Project: $(PROJECT_NAME)"
	@echo "Region: $(AWS_REGION)"
	@echo "Cluster: $(CLUSTER_NAME)"
	@echo "Service: $(SERVICE_NAME)"
	@echo "Stack: $(STACK_NAME)"
	@echo ""
	@echo "$(YELLOW)Stack Outputs:$(NC)"
	@aws cloudformation describe-stacks --stack-name $(STACK_NAME) --region $(AWS_REGION) --query 'Stacks[0].Outputs' --output table 2>/dev/null || echo "Stack not found or no outputs available"





